# -*- coding: utf-8 -*-
"""SWA code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iOh5by2qKS-LyFkjd885dYmqeBrXhcOi
"""

#importing packages required for algorithm

import numpy as np #this is used for handling large arrays of numbers

#Defining the algorithm using match = 3, mismatch =-1, and gap penalty of -2
def smith_waterman(seq1, seq2, match=3, mismatch=-1, gap=-2):
    len_seq1, len_seq2 = len(seq1), len(seq2)
    score_matrix = np.zeros((len_seq1 + 1, len_seq2 + 1), dtype=int) #score matrix
    traceback_matrix = np.zeros((len_seq1 + 1, len_seq2 + 1), dtype=object) #traceback matrix

    # Highest scoring cell variable
    max_score = 0 #initialising the variable
    max_pos = None

    # Fill the score matrix and traceback matrix
    for i in range(1, len_seq1 + 1):
        for j in range(1, len_seq2 + 1):
            score_diag = score_matrix[i - 1, j - 1] + (match if seq1[i - 1] == seq2[j - 1] else mismatch)
            score_up = score_matrix[i - 1, j] + gap
            score_left = score_matrix[i, j - 1] + gap
            score = max(0, score_diag, score_up, score_left)
            score_matrix[i, j] = score #sets up the scoring and directionality of the matrix

            # Calculate gap scores
            score_up = score_matrix[i - 1, j] + gap
            score_left = score_matrix[i, j - 1] + gap

            # Maximum, non-negative scores, scores cannot be negative numbers
            score = max(0, score_diag, score_up, score_left)
            score_matrix[i, j] = score

            # Traceback direction for matrix
            if score == 0:
                traceback_matrix[i, j] = ' '  # Stop
            elif score == score_diag:
                traceback_matrix[i, j] = '\\'  #diagonal direction
            elif score == score_up:
                traceback_matrix[i, j] = '^'  #up direction
            elif score == score_left:
                traceback_matrix[i, j] = '>'  #left direction

            if score > max_score:
                max_score = score #updating scores
                max_pos = (i, j)

    # Optimal local alignment
    aligned_seq1, aligned_seq2, symbols = [], [], [] #initialising variables
    i, j = max_pos
    while traceback_matrix[i, j] != '*' and (i > 0 and j > 0): #if it is not a stop read
        if traceback_matrix[i, j] == '\\':
            aligned_seq1.append(seq1[i - 1])
            aligned_seq2.append(seq2[j - 1])
            symbols.append("|" if seq1[i - 1] == seq2[j - 1] else "*") #depending on if there is a substitution or exact match
            i -= 1
            j -= 1
        elif traceback_matrix[i, j] == '^':
            aligned_seq1.append(seq1[i - 1])
            aligned_seq2.append('-')
            symbols.append(" ")
            i -= 1
        elif traceback_matrix[i, j] == '>':
            aligned_seq1.append('-')
            aligned_seq2.append(seq2[j - 1])
            symbols.append(" ")
            j -= 1

    aligned_seq1 = ''.join(reversed(aligned_seq1)) #reversing the orders of the sequences
    aligned_seq2 = ''.join(reversed(aligned_seq2))
    symbols = ''.join(reversed(symbols))

    # Display results
    print("Alignment Results:")
    print("Sequence 1 Alignment: ", aligned_seq1)
    print("                      ", symbols) #shows mismatches
    print("Sequence 2 Alignment: ", aligned_seq2)
    print("\nScoring Matrix:")
    print(score_matrix)
    print("\nTraceback Directions:")
    for row in traceback_matrix:
        print(" ".join(f"{cell:2}" for cell in row)) #formats it nicely into a square

    return aligned_seq1, aligned_seq2, symbols, score_matrix, traceback_matrix

# Implementing it using sample sequences
seq1 = "ATACCAACTATGGAT"
seq2 = "ATACCAACAAAGGAT"
aligned_seq1, aligned_seq2, symbols, score_matrix, traceback_matrix = smith_waterman(seq1, seq2)
